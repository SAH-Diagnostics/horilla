name: Deploy to AWS Lightsail

concurrency:
  group: lightsail-deploy-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

jobs:
  build-and-deploy:
    name: Build and Deploy Horilla to Lightsail
    runs-on: ubuntu-latest
    timeout-minutes: 45
    env:
      AWS_REGION: 'eu-west-2'
      LIGHTSAIL_STATIC_IP: '3.9.110.17'
      SSH_USER: 'ec2-user'

    steps:
      # 1. Configure AWS Credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      # 2. Get secrets from AWS Secrets Manager
      # Note: Secret is in eu-north-1, so we specify the region explicitly
      - name: Get secrets from AWS Secrets Manager
        env:
          AWS_REGION: eu-north-1
          AWS_DEFAULT_REGION: eu-north-1
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: ${{ secrets.AWS_SECRET_NAME }}
          parse-json-secrets: true
      
      # 2b. Alternative: Fetch secret directly (more reliable)
      # This ensures we get the values regardless of how the action parses them
      - name: Fetch secrets directly from AWS Secrets Manager
        env:
          AWS_REGION: eu-north-1
        run: |
          echo "Fetching secret: ${{ secrets.AWS_SECRET_NAME }}"
          SECRET_JSON=$(aws secretsmanager get-secret-value \
            --secret-id ${{ secrets.AWS_SECRET_NAME }} \
            --region eu-north-1 \
            --query SecretString \
            --output text)
          
          # Parse and export variables (these will override any from the action above)
          export DATABASE_USER=$(echo "$SECRET_JSON" | jq -r '.DATABASE_USER // empty')
          export DATABASE_PASSWORD=$(echo "$SECRET_JSON" | jq -r '.DATABASE_PASSWORD // empty')
          export DATABASE_NAME=$(echo "$SECRET_JSON" | jq -r '.DATABASE_NAME // empty')
          export RDS_ENDPOINT=$(echo "$SECRET_JSON" | jq -r '.RDS_ENDPOINT // empty')
          export SECRET_KEY=$(echo "$SECRET_JSON" | jq -r '.SECRET_KEY // empty')
          export DEBUG=$(echo "$SECRET_JSON" | jq -r '.DEBUG // "False"')
          export ALLOWED_HOSTS=$(echo "$SECRET_JSON" | jq -r '.ALLOWED_HOSTS // "*"')
          export CSRF_TRUSTED_ORIGINS=$(echo "$SECRET_JSON" | jq -r '.CSRF_TRUSTED_ORIGINS // "http://3.9.110.17"')
          
          # Debug: Show what we got (redacted)
          echo "=== Fetched from Secrets Manager ==="
          echo "DATABASE_USER: ${DATABASE_USER}"
          echo "DATABASE_PASSWORD: ${DATABASE_PASSWORD:+***SET***}${DATABASE_PASSWORD:-***NOT SET***}"
          echo "DATABASE_NAME: ${DATABASE_NAME}"
          echo "RDS_ENDPOINT: ${RDS_ENDPOINT}"
          echo "SECRET_KEY: ${SECRET_KEY:+***SET***}${SECRET_KEY:-***NOT SET***}"
          echo "DEBUG: ${DEBUG}"
          echo "ALLOWED_HOSTS: ${ALLOWED_HOSTS}"
          echo "CSRF_TRUSTED_ORIGINS: ${CSRF_TRUSTED_ORIGINS}"
          echo "===================================="
          
          # Validate required variables
          if [ -z "$RDS_ENDPOINT" ]; then
            echo "ERROR: RDS_ENDPOINT is not set in AWS Secrets Manager"
            exit 1
          fi
          
          # Save to GITHUB_ENV so they're available in subsequent steps
          echo "DATABASE_USER=${DATABASE_USER}" >> $GITHUB_ENV
          echo "DATABASE_PASSWORD=${DATABASE_PASSWORD}" >> $GITHUB_ENV
          echo "DATABASE_NAME=${DATABASE_NAME}" >> $GITHUB_ENV
          echo "RDS_ENDPOINT=${RDS_ENDPOINT}" >> $GITHUB_ENV
          echo "SECRET_KEY=${SECRET_KEY}" >> $GITHUB_ENV
          echo "DEBUG=${DEBUG}" >> $GITHUB_ENV
          echo "ALLOWED_HOSTS=${ALLOWED_HOSTS}" >> $GITHUB_ENV
          echo "CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS}" >> $GITHUB_ENV

      # 3. Checkout code
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 4. Setup Docker Buildx
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 5. Build Horilla Docker image
      - name: Build Horilla Docker image
        run: |
          docker build -t horilla-server:${{ github.sha }} .
          docker save horilla-server:${{ github.sha }} | gzip > horilla-server-image.tar.gz

      # 6. Generate deployment configurations (Docker Compose)
      - name: Generate deployment configurations
        run: |
          # Debug: Show all environment variables that start with DATABASE, SECRET, DEBUG, ALLOWED, or CSRF
          echo "=== Debug: Available environment variables ==="
          env | grep -E "^(DATABASE|SECRET|DEBUG|ALLOWED|CSRF)" | sed 's/=.*/=***REDACTED***/' || echo "No matching variables found"
          echo "=============================================="
          echo ""
          
          # The aws-secretsmanager-get-secrets action with parse-json-secrets: true
          # creates environment variables from JSON keys. However, it may prefix them
          # with the secret name. Let's try multiple variations.
          
          # Variables should already be set from the previous step (via GITHUB_ENV)
          # But we'll also check for variations in case the action set them differently
          DATABASE_USER="${DATABASE_USER:-${dev_horilla_DATABASE_USER:-${HORILLA_DATABASE_USER:-postgres}}}"
          DATABASE_PASSWORD="${DATABASE_PASSWORD:-${dev_horilla_DATABASE_PASSWORD:-${HORILLA_DATABASE_PASSWORD}}}"
          DATABASE_NAME="${DATABASE_NAME:-${dev_horilla_DATABASE_NAME:-${HORILLA_DATABASE_NAME:-horilla}}}"
          RDS_ENDPOINT="${RDS_ENDPOINT:-${dev_horilla_RDS_ENDPOINT:-${HORILLA_RDS_ENDPOINT}}}"
          SECRET_KEY="${SECRET_KEY:-${dev_horilla_SECRET_KEY:-${HORILLA_SECRET_KEY}}}"
          DEBUG="${DEBUG:-${dev_horilla_DEBUG:-${HORILLA_DEBUG:-False}}}"
          ALLOWED_HOSTS="${ALLOWED_HOSTS:-${dev_horilla_ALLOWED_HOSTS:-${HORILLA_ALLOWED_HOSTS:-*}}}"
          CSRF_TRUSTED_ORIGINS="${CSRF_TRUSTED_ORIGINS:-${dev_horilla_CSRF_TRUSTED_ORIGINS:-${HORILLA_CSRF_TRUSTED_ORIGINS:-http://3.9.110.17}}}"
          
          # Debug: Show what values we got (redacted for security)
          echo "=== Debug: Resolved values ==="
          echo "DATABASE_USER: ${DATABASE_USER}"
          echo "DATABASE_PASSWORD: ${DATABASE_PASSWORD:+***SET***}${DATABASE_PASSWORD:-***NOT SET***}"
          echo "DATABASE_NAME: ${DATABASE_NAME}"
          echo "RDS_ENDPOINT: ${RDS_ENDPOINT}"
          echo "SECRET_KEY: ${SECRET_KEY:+***SET***}${SECRET_KEY:-***NOT SET***}"
          echo "DEBUG: ${DEBUG}"
          echo "ALLOWED_HOSTS: ${ALLOWED_HOSTS}"
          echo "CSRF_TRUSTED_ORIGINS: ${CSRF_TRUSTED_ORIGINS}"
          echo "=============================================="
          echo ""
          
          # Validate required variables
          if [ -z "$DATABASE_PASSWORD" ]; then
            echo "ERROR: DATABASE_PASSWORD is not set in AWS Secrets Manager"
            echo "Please check:"
            echo "  1. AWS Secrets Manager secret 'dev/horilla' has 'DATABASE_PASSWORD' key"
            echo "  2. The secret value is not empty"
            echo "  3. The IAM role has permissions to read the secret"
            exit 1
          fi
          
          if [ -z "$RDS_ENDPOINT" ]; then
            echo "ERROR: RDS_ENDPOINT is not set in AWS Secrets Manager"
            echo "Please check:"
            echo "  1. AWS Secrets Manager secret 'dev/horilla' has 'RDS_ENDPOINT' key"
            echo "  2. The secret value is not empty"
            exit 1
          fi
          
          if [ -z "$SECRET_KEY" ]; then
            echo "ERROR: SECRET_KEY is not set in AWS Secrets Manager"
            exit 1
          fi
          
          # URL encode the password to handle special characters (#, @, :, /, etc.)
          # Using Python for reliable URL encoding
          ENCODED_PASSWORD=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$DATABASE_PASSWORD', safe=''))")
          
          # Construct DATABASE_URL with URL-encoded password
          DATABASE_URL="postgres://${DATABASE_USER}:${ENCODED_PASSWORD}@${RDS_ENDPOINT}:5432/${DATABASE_NAME}"
          
          echo "=== Generated DATABASE_URL (redacted) ==="
          echo "DATABASE_URL=postgres://${DATABASE_USER}:****@${RDS_ENDPOINT}:5432/${DATABASE_NAME}"
          echo "=========================================="
          echo ""
          
          # Generate docker-compose.deploy.yml for production
          cat > docker-compose.deploy.yml << COMPOSEEOF
          services:
            horilla-server:
              image: horilla-server:${{ github.sha }}
              restart: always
              command: sh ./entrypoint.sh
              ports:
                - '0.0.0.0:8000:8000'
              environment:
                - DATABASE_URL=${DATABASE_URL}
                - SECRET_KEY=${SECRET_KEY}
                - DEBUG=${DEBUG}
                - ALLOWED_HOSTS=${ALLOWED_HOSTS}
                - CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS}
              volumes:
                - horilla-media:/app/media
              healthcheck:
                test: ["CMD", "python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8000').read()"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 60s

          volumes:
            horilla-media:
          COMPOSEEOF

          # Generate .env file for reference (not strictly needed since we're using environment: directly)
          cat > .env.deploy << EOF
          DATABASE_USER=${DATABASE_USER}
          DATABASE_PASSWORD=${DATABASE_PASSWORD}
          DATABASE_NAME=${DATABASE_NAME}
          RDS_ENDPOINT=${RDS_ENDPOINT}
          DATABASE_URL=${DATABASE_URL}
          SECRET_KEY=${SECRET_KEY}
          DEBUG=${DEBUG}
          ALLOWED_HOSTS=${ALLOWED_HOSTS}
          CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS}
          EOF

          # Debug: Display generated files (without sensitive data)
          echo "=== Generated docker-compose.deploy.yml ==="
          cat docker-compose.deploy.yml
          echo "============================================"
          echo "=== .env.deploy (redacted) ==="
          sed 's/=.*/=***REDACTED***/g' .env.deploy
          echo "============================================"

      # 7. Setup SSH key
      - name: Setup SSH key
        run: |
          echo "Fetching SSH key directly from AWS..."
          mkdir -p ~/.ssh
          
          aws secretsmanager get-secret-value \
            --secret-id ${{ secrets.AWS_SECRET_NAME }} \
            --region eu-north-1 \
            --query 'SecretString' \
            --output text | jq -r '.LIGHTSAIL_SSH_PRIVATE_KEY' > ~/.ssh/lightsail_key.pem
          echo "Setting key permissions..."
          chmod 600 ~/.ssh/lightsail_key.pem
          
          echo "Adding host to known_hosts..."
          ssh-keyscan -H ${{ env.LIGHTSAIL_STATIC_IP }} >> ~/.ssh/known_hosts

      # 8. Transfer files to Lightsail instance
      - name: Copy deployment files to Lightsail
        run: |
          scp -i ~/.ssh/lightsail_key.pem \
            horilla-server-image.tar.gz \
            docker-compose.deploy.yml \
            .env.deploy \
            ${{ env.SSH_USER }}@${{ env.LIGHTSAIL_STATIC_IP }}:~/

      # 9. Deploy on Lightsail
      - name: Deploy to Lightsail
        run: |
          ssh -i ~/.ssh/lightsail_key.pem ${{ env.SSH_USER }}@${{ env.LIGHTSAIL_STATIC_IP }} << 'ENDSSH'
            set -e
            echo "Loading Docker image..."
            docker load < horilla-server-image.tar.gz
            
            echo "Deploying containers with rolling update..."
            docker compose -f docker-compose.deploy.yml up -d --force-recreate
            
            echo "Waiting for containers to start..."
            sleep 20
            
            echo "Checking container status..."
            docker compose -f docker-compose.deploy.yml ps
            
            echo "Checking horilla-server logs..."
            docker compose -f docker-compose.deploy.yml logs --tail=50 horilla-server
            
            echo "Waiting for health checks (this may take up to 60 seconds)..."
            for i in {1..6}; do
              if docker compose -f docker-compose.deploy.yml ps | grep -q "unhealthy"; then
                echo "Attempt \$i: Container still unhealthy, waiting..."
                sleep 10
              else
                echo "Health check passed!"
                break
              fi
            done
            
            # Final status check - warn but don't fail
            if docker compose -f docker-compose.deploy.yml ps | grep -q "unhealthy"; then
              echo "⚠️  WARNING: Container health check failed. Showing logs:"
              docker compose -f docker-compose.deploy.yml logs --tail=100 horilla-server
              echo "⚠️  WARNING: Deployment completed but service may not be fully operational"
              echo "⚠️  Please check the logs above and verify the application manually"
            else
              echo "✅ Deployment successful, containers are healthy"
            fi
            
            echo "Cleaning up old images..."
            docker image prune -f
            
            echo "Deployment complete!"
          ENDSSH

      # 10. Verify deployment
      - name: Verify deployment
        run: |
          ssh -i ~/.ssh/lightsail_key.pem ${{ env.SSH_USER }}@${{ env.LIGHTSAIL_STATIC_IP }} << 'ENDSSH'
            echo "=== Container Status ==="
            docker compose -f docker-compose.deploy.yml ps
            echo -e "\n=== Server Logs (last 30 lines) ==="
            docker compose -f docker-compose.deploy.yml logs --tail=30 horilla-server
          ENDSSH

      # 11. Cleanup
      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/lightsail_key.pem

